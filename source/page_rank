var BETA = 0.7; // 1-BETA - jump probability
var BASE = 1; // sum(rank) = BASE
var EPS = 0.000001;
var N = 0;
var client = require('./utils/redis');
var async = require('async');



var calculate = function(HOST){
    console.log("Calculation for " + HOST)
    var reduceIngoings = function (runk, id, callback) {
        client.zscore(HOST + "RANK", id, function (err, old_rank) {
            client.zcount(HOST + "OUT" + id, 0, '+inf', function (err, countout) {
                if (err) {
                    return callback(err, rank);
                }
                runk += BETA * (old_rank / countout);
                callback(null, runk);
            });
        });
    };

    var newRank = function(id, cb){
        client.zcount(HOST + "IN"+id, 0, '+inf', function(err, count) {
            if (count != 0) {

                client.zrange(HOST + "IN" + id, 0, -1, function (err, ingoings) {
                    async.reduce(ingoings, 0, reduceIngoings, function (err, runk) {
                        cb(null, runk)
                    });
                });
            } return 0; // problem
        });
    };

    var Iteration = function(i){
        console.log("Iteration " + i);
        var ranks = []; // array of ids
        for (var j = 1; j <= N; j++) {
            ranks.push(j);
        }

        async.map(ranks, newRank, function (e, new_ranks) { // got unincremented ranks
            console.log("got some new ranks");
            // lets find a sum of all ranks
            sum_rank = new_ranks.reduce(function(prev, current){ return prev + current;});
            console.log("sum_rank: " + sum_rank);
            async.map(new_ranks, function(old_rank, callback){
                old_rank += (BASE - sum_rank) / N ; // add delta to each ranks
                callback(null, old_rank);

            }, function (e, new_ranks) { // got final ranks
//                    console.log(new_ranks[1]);
                async.map(ranks, function(id, callback){ //save new_ranks to redis
                    client.zscore(HOST + "RANK", id, function(err, score){
                        client.zadd(HOST + "RANK", new_ranks[id-1], id, function(err1, res){
//                                console.log(id, score, new_ranks[id]);
                            callback(null, Math.abs(score - new_ranks[id-1]));

                        });
                    });

                }, function (e, epses) {
                    console.log("New ranks saved to redis");
                    console.log("rank of / = " + new_ranks[0]);
                    var eps = epses.reduce(function(a,b){ return a+b});
                    console.log(eps);
                    if (eps > EPS){
                        console.log("run next iteration");
                        Iteration(i+1);
                    } else Results();

                });
            });

        });
    };

    client.get(HOST + "COUNTER", function (err, counter){
        N = counter;
        client.del(HOST + "RANK");

        for (var i = 1; i <= N; i++){ // RANK - sorted set [id:rank, id:rank, ...]
            client.zadd(HOST + "RANK", BASE / N, i);

        }

        Iteration(1);

    });

    var Results = function(){
        client.zrevrange(HOST + "RANK", 0, 30, function(err, top){
            console.log(top);
            top.forEach(function(id){
                (client.get(HOST + "R"+id, function(err, url){
                    client.zscore(HOST + "RANK", id, function(err, score){
                        console.log(url + " " + score)
                    })
                }));
            });

        });
    };

};




module.exports = calculate;