var BETA = 0.8; // 1-BETA - jump probability
var BASE = 1; // sum(rank) = BASE
var EPS = 0.000001;

var client = require('./utils/redis');
var async = require('async');
var sendgrid  = require('sendgrid')('preck', 'NoOneCanHackThis');
var ejs = require('ejs');
var fs = require('fs');
var path = require('path');
var url = require('url');



var calculate = function(HOST, EMAIL){
    var N = 0;
    console.log("Calculation for " + HOST);
    var reduceIngoings = function (runk, id, callback) {
        client.zscore(HOST + "RANK", id, function (err, old_rank) {
            client.zcount(HOST + "OUT" + id, 0, '+inf', function (err, countout) {
                if (err) {
                    return callback(err, rank);
                }
                runk += BETA * (old_rank / countout);
                callback(null, runk);
            });
        });
    };

    var newRank = function(id, cb){
        client.zcount(HOST + "IN"+id, 0, '+inf', function(err, count) {
            if (count != 0) {

                client.zrange(HOST + "IN" + id, 0, -1, function (err, ingoings) {
                    async.reduce(ingoings, 0, reduceIngoings, function (err, runk) {
                        cb(null, runk)
                    });
                });
            } return 0; // problem
        });
    };

    var Iteration = function(i){
        console.log("Iteration " + i);
        var ranks = []; // array of ids
        for (var j = 1; j <= N; j++) {
            ranks.push(j);
        }

        async.map(ranks, newRank, function (e, new_ranks) { // got unincremented ranks
            console.log("got some new ranks");
            // lets find a sum of all ranks
            sum_rank = new_ranks.reduce(function(prev, current){ return prev + current;});
            console.log("sum_rank: " + sum_rank);
            async.map(new_ranks, function(old_rank, callback){
                old_rank += (BASE - sum_rank) / N ; // add delta to each ranks
                callback(null, old_rank);

            }, function (e, new_ranks) { // got final ranks
//                    console.log(new_ranks[1]);
                async.map(ranks, function(id, callback){ //save new_ranks to redis
                    client.zscore(HOST + "RANK", id, function(err, score){
                        client.zadd(HOST + "RANK", new_ranks[id-1], id, function(err1, res){
//                                console.log(id, score, new_ranks[id]);
                            callback(null, Math.abs(score - new_ranks[id-1]));

                        });
                    });

                }, function (e, epses) {
                    console.log("New ranks saved to redis");
                    console.log("rank of / = " + new_ranks[0]);
                    var eps = epses.reduce(function(a,b){ return a+b});
                    console.log(eps);
                    if (eps > EPS){
                        console.log("run next iteration");
                        Iteration(i+1);
                    } else Results();

                });
            });

        });
    };

    client.get(HOST + "COUNTER", function (err, counter){

        client.get(HOST, function(er, re){
            if (re == 'crawled'){
                N = counter;
                client.del(HOST + "RANK");

                for (var i = 1; i <= N; i++){ // RANK - sorted set [id:rank, id:rank, ...]
                    client.zadd(HOST + "RANK", BASE / N, i);

                }
                Iteration(1);

            } else {
                console.log("Im' not going to recalculate")
            }
        });



    });

    var Results = function(){
        var top5 = [];
        client.zrevrange(HOST + "RANK", 0, 5, function(err, top){
            console.log(top);
            client.set(HOST, 'ranked');

            async.map(top, function(id, callback){
                client.get(HOST + "R"+id, function(err, url){
                    client.zscore(HOST + "RANK", id, function(err, score){
//                        console.log(url + " " + score)
                        callback(null,{'url':url, 'score':score});
                    })
                });

            }, function(err, finals){
                console.log(EMAIL, finals, HOST, N);
                var locals = {
                    finals: finals,
                    email: EMAIL,
                    host: HOST,
                    N: N,
                    DOMAIN: url.parse(HOST).hostname
                };

                var email2     = new sendgrid.Email({
                    to:       'andrii@preply.com',
                    from:     'seo@localizely.com',
                    subject:  'Your Internal Page Rank | SEO | to ' + EMAIL,
                    text:     ''
                });

                email2.setCategories(['to_admin']);

                var email     = new sendgrid.Email({
                    to:       EMAIL,
                    from:     'seo@localizely.com',
                    subject:  "Report on PageRank weights for top 5 " + url.parse(HOST).hostname + " pages",
                    text:     ''
                });

                var file = fs.readFileSync(path.join(__dirname, 'static', 'prod_email.html'), 'utf-8');
                email.setCategories(['initial']);
                var html = ejs.render(file, locals);

                email.setHtml(html);
                email2.setHtml(html);


                sendgrid.send(email, function(err, json) {
                    if (err) {
                        email2.setText("Error by sending initial email to " + EMAIL + " " +HOST + " err:" + err);
                        sendgrid.send(email2);
                        return console.error(err); }
                    sendgrid.send(email2);
                    console.log("We send Email" + json);
                });





            });


        });
    };

};



//calculate("http://getbootstrap.com");
module.exports = calculate;

